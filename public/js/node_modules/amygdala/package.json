{
  "name": "amygdala",
  "version": "0.4.3",
  "description": "RESTful HTTP library for JavaScript powered web applications",
  "keywords": [
    "REST",
    "client",
    "http",
    "API",
    "localStorage",
    "store",
    "browser",
    "library",
    "cache",
    "ajax",
    "offline"
  ],
  "homepage": "https://github.com/lincolnloop/amygdala",
  "bugs": {
    "url": "https://github.com/lincolnloop/amygdala/issues"
  },
  "author": {
    "name": "Marco Louro",
    "email": "marco@lincolnloop.com",
    "url": "http://lincolnloop.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/lincolnloop/amygdala.git"
  },
  "main": "amygdala.js",
  "files": [
    "amygdala.js"
  ],
  "scripts": {
    "test": "mocha --reporter spec --ui bdd"
  },
  "testling": {
    "harness": "mocha-bdd",
    "files": "test/*.test.js",
    "browsers": [
      "ie/9..latest",
      "chrome/26..latest",
      "firefox/22..latest",
      "safari/latest",
      "opera/12.0..latest",
      "iphone/latest",
      "ipad/latest",
      "android-browser/latest"
    ]
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/lincolnloop/amygdala/blob/master/LICENSE"
    }
  ],
  "devDependencies": {
    "chai": "^1.9.0",
    "mocha": "^1.17.1",
    "sinon": "^1.9.0",
    "sinon-chai": "^2.5.0",
    "xmlhttprequest": "^1.6.0",
    "lodash": "^2.4.1",
    "gulp-rename": "^1.2.0",
    "gulp-wrap": "^0.3.0",
    "gulp": "^3.5.6",
    "gulp-browserify": "^0.5.0",
    "gulp-uglify": "^0.2.1"
  },
  "dependencies": {
    "underscore": "^1.6.0",
    "q": "^1.0.1",
    "wolfy87-eventemitter": "^4.2.6"
  },
  "readme": "![Amygdala logo](https://raw.githubusercontent.com/lincolnloop/amygdala/master/static/logo.png)\n\nAmygdala is a RESTful HTTP library for JavaScript powered web applications. Simply configure it once with your API schema, and easily do GET, POST, PUT and DELETE requests with minimal effort and a consistent API.\n\nExamples:\n\n```javascript\n// GET\nstore.get('users').done(function() { ... });\n\n// POST\nstore.add('teams', {'name': 'Lincoln Loop', 'active': true}).done(function() { ... });\n```\n\n[![browser support](https://ci.testling.com/lincolnloop/amygdala.png)\n](https://ci.testling.com/lincolnloop/amygdala)\n\n## How it works\n\n### 1. INSTALL\n\n\n#### NPM/Browserify\n\n`npm install amygdala`.\n\n\n#### Bower\n\n`bower install amygdala`\n\n\n#### Browser\n\nDownload the latest [amygdala.js](https://github.com/lincolnloop/amygdala/blob/master/amygdala.js) file. Minified/build version coming soon.\n\n##### Dependencies:\n\n* [underscore](https://github.com/jashkenas/underscore): ^1.6.0\n* [q](https://github.com/kriskowal/q): ^1.0.1\n* [Wolfy87/EventEmitter](https://github.com/Wolfy87/EventEmitter): ^4.2.6\n\n\n### 2. SETUP\n\nTo create a new store, define the few possible settings listed below and your API schema.\n\n```javascript\nvar store = new Amygdala({\n  'config': {\n    'apiUrl': 'http://localhost:8000',\n    'idAttribute': 'url',\n    'headers': {\n      'X-CSRFToken': getCookie('csrftoken')\n    },\n    'localStorage': true\n  },\n  'schema': {\n    'users': {\n      'url': '/api/v2/user/'\n    },\n    'teams': {\n      'url': '/api/v2/team/',\n      'orderBy': 'name',\n      'oneToMany': {\n        'members': 'members'\n      },\n      parse: function(data) {\n        return data.results ? data.results : data;\n      },\n    },\n    'members': {\n      'foreignKey': {\n        'user': 'users'\n      }\n    }\n  }\n});\n```\n\n#### Configuration options:\n\n  * apiUrl - Full path to your base API url (required).\n  * idAttribute - global primary key attribute (required). \n  * headers - Any headers that you need to pass on each API request.\n  * localStorage - enable/disable the persistent localStorage cache.\n\n#### Schema options:\n  \n  * url - relative path for each \"table\" (required)\n  * orderBy - order by which you want to retrieve local cached data. eg (name, -name (for reverse))\n  * parse - Accepts a parse method for cases when your API also returns extra meta data.\n\n\n#### Schema relations:\n\nWhen you want to include related data under a single request, for example, to minimize HTTP requests, having schema relations allows you to still have a clean separation when interacting with the data locally.\n\nConsider the following schema, that defines discussions that have messages, and messages that have votes:\n\n```javascript\nvar store = new Amygdala({\n    'config': {\n      'apiUrl': 'http://localhost:8000',\n      'idAttribute': 'url'\n    },\n    'schema': {\n      'discussions': {\n        'url': '/api/v2/discussion/',\n        'oneToMany': {\n          'children': 'messages'\n        }\n      },\n      'messages': {\n        'url': '/api/v2/message/',\n        'oneToMany': {\n          'votes': 'votes'\n        },\n        'foreignKey': {\n          'discussion': 'discussions'\n        }\n      },\n      'votes': {\n        'url': '/api/v2/vote/'\n      }\n    }\n  }\n);\n```\n\nIn this scenario, doing a query on a discussion will retrieve all messages and votes for that discussion:\n\n```javascript\nstore.get('discussions', {'url': '/api/v2/discussion/85273/'}).then(function(){ ... });\n```\n\nSince we defined relations on our schema, the message and vote data won't be stored on the discussion \"table\", but on it's own \"table\" instead.\n\n##### OneToMany:\n\n```javascript\n'oneToMany': {\n  'children': 'messages'\n}\n```\n\n`OneToMany` relations are the most common, and should be used when you have related data in form of an array. In this case, `children` is the attribute name on the response, and `messages` is the destination \"table\" for the array data.\n\n\n##### foreignKey:\n\n```javascript\n'foreignKey': {\n  'discussion': 'discussions'\n}\n```\n\n`foreignKey` relations are basically for one to one relations. In this case Amygdala will look for an object as value of `discussion` and move it over to the `discussions` \"table\" if one is found.\n\n\n### 3. USAGE\n\n#### Querying the remote API server:\n\nThe methods below, allow you to make remote calls to your API server.\n\n```javascript\n// GET\nstore.get('users').done(function() { ... });\n\n// POST\nstore.add('teams', {'name': 'Lincoln Loop', 'active': true}).done(function() { ... });\n\n// PUT\nstore.update('users', {'url': '/api/v2/user/32/', 'username': 'amy82', 'active': true}).done(function() { ... });\n\n// DELETE\nstore.remove('users', {'url': '/api/v2/user/32/'}).done(function() { ... });\n```\n\n\n#### In memory storage API:\n\nOn top of this, Amygdala also stores a copy of your data locally, which you can access through a couple different methods:\n\n\n###### Find and filtering:\n\n```javascript\n// Get the list of active users from memory\nvar users = store.findAll('users', {'active': true});\n\n// Get a single user from memory\nvar user = store.find('users', {'username': 'amy82'});\n\n// Get a single user by id for memory\nvar user = store.find('users', 1103747470);\n```\n\nIf you enable `localStorage`, the data is kept persistently. Because of this, once you instantiate Amygdala, your cached data will be loaded, and you can use it right away without having to wait for the remote calls. (We do not recommend using `localStorage` for production yet)\n\n\n##### Fetching related data:\n\nBy defining your schema and creating relations between data, you are then able to query your data objects for the related objects.\n\nIn the example schema above, discussions have a oneToMany relation with messages, and messages have a foreignKey relation back to discussions. This is how it you can use them.\n\n```javascript\n// Fetching related messages for a discussion (oneToMay)\nvar messages = store.find('discussions', '/api/v2/discussion/85273/').getRelated('messages');\n\n// Getting the discussion object from a message (foreignKey)\nvar discussion = store.find('message', '/api/v2/message/81273/').getRelated('discussion');\n```\n\nNote that Amygdala doesn't fetch data automagically for you here, so it's up you to fetch it before running the query.\n\n## Events\n\nAmygdala uses [Wolfy87/EventEmitter](https://github.com/Wolfy87/EventEmitter) under the hood\nto trigger some very basic events. Right now it only triggers two different events:\n\n* change\n* change:type\n\nTo listen to these events, you can use any of [Event Emitter's](https://github.com/Wolfy87/EventEmitter/blob/master/docs/guide.md#using-eventemitterr) binding methods or the [aliases](https://github.com/Wolfy87/EventEmitter/blob/master/docs/guide.md#method-aliases), the most common one being `on`:\n\n```javascript\n// Listen to any change in the store\nstore.on('change', function() { ... });\n\n// Listen to any change of a specific type\nstore.on('change:users', function() { ... });\n```\n",
  "readmeFilename": "README.md",
  "_id": "amygdala@0.4.3",
  "_from": "amygdala@*"
}
